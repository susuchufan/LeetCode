# LeetCode
## 20210408-153
### Find Minimum in Rotated Sorted Array
好的 就这样开始吧   
我的第一个~~正式的~~Markdown文档  
***
金星曾经说过：  
“理想的生活应从选择和牺牲开始，以勇气和责任终结。”  
第一天，把这句话送给以后每一天的自己。
***
**<center>I solemnly swear that I am up to no good</center>**
***
首先描述一下题目：  
给定一个int型数组，数组中每个元素都是不同的，并且在初始时是升序的，它可以经过多次旋转（一次旋转操作就是将数组末位的元素放置在首位）变为新的数组。问题的输入是一个已被旋转的数组，要求我们输出这个数组中值最小的元素。  
经过简单的分析，我们知道，这个数组如果经过旋转，那么它基本可以看成是**两个升序的数组的拼接**，我们只需要找到拼接的位置，即可找到数组的最小值；如果旋转次数为零，即数组首位元素就是最小值。  
简单的思路就是先根据首尾元素的大小关系来判断数组是否经过旋转，若经过旋转则从头遍历数组，找到拼接位置，为了减小时间复杂度，我们使用**二分查找**来找这个拼接的位置。  
~~不会写主函数~~为了简洁 在这里仅贴出Class的代码：
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int min = nums[0];                //首先让最小值等于首位元素
        int i = 0;                        //i作为每次二分查找的头
        int j = n - 1;                    //j作为每次二分查找的尾
        if (nums[i] > nums[j]) {          //如果头元素大于尾元素，说明有旋转操作
			//当查找元素个数大于2的时候，进行查找循环（因为如果查找元素小于等于2，我们肯定已经找出了最小元素）
            while (j - i != 1) {          
                int k = (i + j) / 2;
                if (nums[i] > nums[k]) {
                    j = k;
                } else {
                    i = k;
                }
            }
            min = nums[j];
        }
    return min;    
    }
};
```
结束了，希望我文字能让你更加喜欢编程！  
***
**<center>Mischief managed</center>**  

***
